<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.89.0-DEV" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Manan&#39;s site</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="马南的个人站点">
		<meta property="og:title" content="Manan&#39;s site" />
<meta property="og:description" content="马南的个人站点" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


		<meta itemprop="name" content="Manan&#39;s site">
<meta itemprop="description" content="马南的个人站点">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Manan's site">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="Manan&#39;s site" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/images/avatar.png">
				</div><div class="logo__item logo__text">
					<div class="logo__title">Manan&#39;s site</div>
					<div class="logo__tagline">computer science &amp; philosophy</div>
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/%E5%8D%9A%E5%BC%88%E6%A0%91%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/" rel="bookmark">
			博弈树的启发式搜索
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-11-15T00:00:00Z">2021-11-15</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 博弈树是一种基于与或图的启发式搜索算法。博弈主要分为两类，一是机遇性博弈，还有就是完备性博弈。机遇性博弈中参与博弈的玩家之间信息是不完备的，并且博弈中事件的发生具有概率性，日常中大部分的博弈都是机遇性博弈。完备性博弈是指参与博弈的玩家之间都掌握着博弈对手的完整信息，基于已掌握的信息对博弈进程进行推演。完备性博弈是一种理想的博弈，通常出现在棋牌类的游戏中。
对于一种博弈的游戏，参与者可能会有多个。基于与或图的博弈树启发式搜索只能应用于双人完备信息博弈。这种搜索算法也称为Max-Min搜索（极大极小搜索）。
与或图也称为与或树，是一种特殊的树结构。与或树是多叉树，每个节点的类型要么是与节点，要么是或节点。通常可以将与或树应用于问题求解上，对于一个问题可以将其归约为许多子问题的求解。这样的一个问题归约的过程就可以用与或树进行表示。其中原命题为与或树的跟节点，分解出的子命题为与或树的孩子节点。如果分解出子命题中一个命题有解就可以导致原命题有解，就把原命题所在节点命名为或节点，反之若需要所有子命题都有解才能导致原命题有解，那么这个节点就是与节点。
极大极小搜索 双人完备信息博弈中，假设博弈一方是MAX，另一方是MIN。对于MAX来说自己可选的行动方案都是或的关系，因为主动权掌握在MAX手中。而对手MIN所作出的所有决策在MAX看来都是与的关系，因为当主动权掌握在MIN手中后，MAX不得不考虑到MIN所有可能的决策结果，这样MAX才能作出对于自己最有利的决策。
基于如上的假设与考量结合双人完备信息博弈游戏的特点，可以总结出博弈树有如下特征：
  博弈过程必须有立场，要么站在MAX的立场上，要么站在MIN的立场上。
  博弈树中与节点与或节点是逐层交替出现的，其中根节点是或极点。或节点代表MAX所面临的博弈状态（MIN决策之后的博弈状态），与节点代表MIN所面临的博弈状态（MAX决策之后的博弈状态）。
  
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/javascript-zx%E7%94%A8js%E5%86%99shell%E8%84%9A%E6%9C%AC/" rel="bookmark">
			JavaScript ZX——用JS写Shell脚本
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-11-14T00:00:00Z">2021-11-14</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZX库简介 zx是Google推出的一个运行在Node.js环境下的方便开发人员编写命令行脚本程序的类库。
命令脚本程序是基于特定操作系统，方便完成的一系列批处理工作的脚本程序。在Unix-like的操作系统，通常是使用shell脚本。在Windows系统中使用的则是bat脚本。
这类批处理脚本都有一个共同的特点——语法晦涩不好编写。对于开发人员来说，掌握shell编程的收益并不大。好在Google推出了一款可以在Node运行时环境中进行shell编程的工具类库zx
zx的Github项目地址为https://github.com/google/zx，此项目在笔者写下这篇文章时就已经有23k左右的star了，可见这个库确实解决了开发人员的一个痛点。
ZX库的安装 安装ZX之前，需要确保本机具有Node的运行时环境。如果没有安装，可以去NodeJS官网下载，地址为：https://nodejs.org/en/。
NodeJS的安装完毕后，你就可以使用npm（Node Package Manager）来安装zx了。
sudo npm install -g zx 使用ZX写一段shell脚本 zx提供了许多封装好的函数方便你进行shell编程。
例如：question函数，对readline进行了封装，可以更方便的接收shell的输入。同时zx还提供了fetch函数，可以更好的进行网络数据的请求。
在zx中以$符号开头的代表这是一个shell命令，它会立即执行并返回一个Promise，这个Promise被定义为
class ProcessPromise&lt;T&gt; extends Promise&lt;T&gt; { readonly stdin: Writable readonly stdout: Readable readonly stderr: Readable readonly exitCode: Promise&lt;number&gt; pipe(dest): ProcessPromise&lt;T&gt; kill(signal = &#39;SIGTERM&#39;): Promise&lt;void&gt; } ProcessPromise的返回值为：
class ProcessOutput { readonly stdout: string readonly stderr: string readonly exitCode: number toString(): string } 其中如果shell命令执行成功，那么exitCode字段将被设置为0。同时shell命令执行后的输出将会被保存在stdout中。如果执行失败，那么exitCode将为一个非零的整数，命令的输出将会被保存在stderr中。
同时你也可以对shell命令执行后的输出进行重定向：
$`git pull`.pipe(streamVar) Demo：自动提交当前代码
#!/usr/bin/env zx  // 注意$返回的是一个Promise let { exitCode } = await $&#34;git add .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/javascript-zx%E7%94%A8js%E5%86%99shell%E8%84%9A%E6%9C%AC/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/swing%E7%B1%BB%E5%BA%93%E6%B1%87%E6%80%BB/" rel="bookmark">
			Java Swing类库汇总
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-11-13T00:00:00Z">2021-11-13</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swing类库汇总   🌸Look And Feel 外观
 BeautyEye L&amp;F（国人开发） 🏠 HomePage: http://docs.52im.net/extend/docs/src/beautyeye3/ 🛒 Github: https://github.com/JackJiang2011/beautyeye 📦 Maven Repository: ❎ Flat L&amp;F 🏠 HomePage: https://www.formdev.com/flatlaf/ 🛒 Github: https://github.com/JFormDesigner/FlatLaf 📦 Maven Repository: ✅ Dark L&amp;F 🏠 HomePage: https://weisj.github.io/darklaf-docs/ 🛒 Github: https://github.com/bulenkov/Darcula 📦 Maven Repository: ✅ Substance L&amp;F 🏠 HomePage: ❌ 🛒 Github: https://github.com/kirill-grouchnikov/radiance 📦 Maven Repository: ✅ Web L&amp;F 🏠 HomePage: http://weblookandfeel.com/ 🛒 Github: https://github.com/mgarin/weblaf 📦 Maven Repository: ✅    🛠实用工具类库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/swing%E7%B1%BB%E5%BA%93%E6%B1%87%E6%80%BB/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/%E5%B0%86java%E7%BC%96%E8%AF%91%E4%B8%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81/" rel="bookmark">
			将Java编译为本地代码
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-11-13T00:00:00Z">2021-11-13</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		将Java编译为本地代码 通常Java程序的执行流程为：将Java代码编译为Byte Code（字节码），然后JVM执行引擎执行编译好的Byte Code。这是一种中间语言的特性，它的好处就是可以做到平台的无关性，一份代码可以在任意的平台上运行。而且JVM语言采用了JIT（Just In Time）即时编译技术，会将执行中的热点代码（字节码）编译为本地代码运行，提高代码执行性能。
虽然Java的这种中间语言+即时编译的技术有很多优点，同时也有很多缺点。比如JVM执行引擎执行会比较占用资源，而且JIT有热加载的问题，所以执行的性能发挥不太稳定。对于软件的发布来说，我们通常会将JRE连同我们的应用程序一同发布，这样虽然能解决用户PC上JRE版本与要求版本不一致问题，但是也增大了软件包的体积。
针对上述JVM存在的问题，Oracel公司推出了一个名为GraalVM的项目，这个项目可以将Java字节码编译为本地代码。编译生成的本地代码无须JVM，可以直接在目标机器上运行。而且这种AOT（Ahead Of Time）的编译方式并不会对性能造成太大的影响，同时它还能够减少运行时的内存占用与CPU资源消耗。具体的其他特性，可以查看GraalVM官网。
GraalVM安装（OSX） GraalVM JDK可以与你本机的JDK互补的存在，GraalVM并没有提供相应的安装程序，而是以压缩的包的形式进行发布，你可以从Github上进行下载：https://github.com/graalvm/graalvm-ce-builds/releases/tag/vm-21.0.0.2
下载完毕后解压缩至相应目录即可。
安装完毕GraalVM之后，你可以安装native-image本地代码编译工具，这个工具需要依赖于GraalVM，所以在安装这个工具前，请先安装GraalVM。native-image本地代码编译工具也可以在上文中的Github仓库中进行下载，它也是压缩包的形式进行发布的，下载下来解压即可。但是与GraalVM不同的是这个工具并不是开箱即用，而是需要一些配置。
sudo xattr -r -d com.apple.quarantine /path/to/GRAALVM_HOME &lt;GraalVM安装目录&gt;/Contents/Home/bin/gu install native-image 执行完这个命令后，native-image就会安装到GraalVM的bin目录下。
测试编译本地代码 Java源代码：
public class Test { public static void main(String... args) { System.out.println(&#34;Hello world&#34;); } } 将源代码编译为字节码：
javac Test.java 将字节码编译为本地代码：
native-image Test 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" rel="bookmark">
			哈夫曼树与哈夫曼编码
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-10-31T00:00:00Z">2021-10-31</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 哈夫曼树(Huffman Tree)也是一种树，与其他树不同的是哈夫曼树的构造方式。在哈夫曼树的构造过程中有一个参考指标——带权路径长度。
路径是指从树中一个节点出发到另一个节点之间的分支，分支的数目称为路径长度。带权路径长度是考虑到节点之间的权重大小之后的一个指标参数，数值上它等于路径长度与该路径上所有节点的权重乘积。
$$ WPL = \sum_{i = 1}^{n} W_i \times L_i $$
哈夫曼树是带权节点集合中构造出的WPL最小的二叉树。Huffman树本质上也是一种二叉树，同时由于其WPL最小，所以也称之为最优二叉树。
哈夫曼编码是在哈夫曼树这种数据结构基础之上的一种编码方式。常见的编码方式主要分为两种——等长编码和变长编码。
等长编码是指将待编码数据全部映射为长度大小一致的二进制序列，这样的编码编解码都很方便，也容易实现。但是缺点也很明显，这样的编码得到的字节序列会较大，在存储与传输过程中比较消耗资源。比较常见的ASCII码就是一种等长度编码的形式。
变长编码是指将待编码数据由一定规则指定编码为长度不一致的二进制序列，变长编码的优势在于能够实现对数据的无损压缩（相较于等长度编码，变长编码后的体积更小而且不损伤数据的完整性），但是编解码比较困难。
哈夫曼树的构造 哈夫曼树的构造算法需要所有带权节点构成森林（树节点的集合）作为输入，集合中每个树节点的左子树与右子树均为空。
  从集合中选择一个权重最小的节点M0和权重次小的节点M1。
构造一个新的节点N0，N0左子树为M0,右子树为M1。
N0节点的权重大小为M0的权重加上M1的权重。
将M0和M1从集合中删除，并将新构造的N0节点放入集合中。
  重复步骤1，直至集合中只剩下一个节点
  哈夫曼树的特点 从哈夫曼树的构造中可以看出，哈夫曼树有以下特点：
  叶子节点存储有效信息。
  哈夫曼树中不存在出度为1的节点，即每个节点要么没有左右子树，要么都有左右子树。
  若初始森林中树节点的个数为N，则哈夫曼树中的节点个数为2N - 1。
  哈夫曼编码 哈夫曼树构造完成之后，就已经确定了对特定数据的哈夫曼编码。
数据的编码由该数据在哈夫曼树中的路径确定，具体形式为：从根节点出发，沿左子树行走为0，沿右子树行走为1。如图所示，节点A的路径为{left, left, left}，故其编码为000。节点B的路径为{left, left, right}，故其编码为001。
从图中便可看出哈夫曼编码属于变长编码，数据的编码长度并不相同。
哈夫曼解码 数据经过编码之后可以得到一串由0，1组成的二进制序列。解码就是将这串二进制序列重新变为原始数据的过程。解码的过程中需要用到将数据编码的哈夫曼树，其具体的操作流程为：
  遍历二进制序列，遇到0则沿哈夫曼树向左走，遇到1则沿哈夫曼树向右走。
  若哈夫曼树的当前节点为叶子节点，则完成了一个数据的解码。将解码数据保存，重新回到哈夫曼的的根节点。
  重复步骤1，2直到序列被遍历完。
  附录A——哈夫曼节点定义 class HuffmanNode&lt;T&gt;( var left: HuffmanNode&lt;T&gt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8086%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" rel="bookmark">
			8086字符串操作
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-10-15T00:00:00Z">2021-10-15</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 8086关于字符串的五种操作指令：
  MOVS (MOVE BYTE OR WORD STRING)
  CMPS (COMPARE BYTE OR WORD STRING)
  SCAS (SCAN BYTE OR WORD STRING)
  LODS (LOAD BYTE OR WORD STRING)
  STOS (STORE BYTE OR WORD STRING)
  从指令的全称中可以看到，8086对于字符串的操作既可以对字节进行操作，也可以对字进行操作。
上述指令的寻址方式均为隐含寻址，若SRC在存储器中，则数据地址由DS:SI提供，若SRC在寄存器中，则对字节操作时数据在AL中，对字操作时数据在AX中。若DST在存储器中，则数据地址必须由 ES:DI确定。若DST在寄存器中，则对字节操作时数据在AL中，对字操作时数据在AX中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/" rel="bookmark">
			8086寻址方式
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-09-24T17:07:35&#43;08:00">2021-09-24</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 一条汇编指令包含了操作码和操作数两部分，而操作数又分为目的操作数（DST）和源操作数（SRC）两种。汇编指令就是操作码与操作数的结合，有的操作码需要两个操作数（即DST和SRC）有的只需要一个操作数（例如PUSH），还有的不需要操作数（例如CLI）。
这种差异性便是寻址方式的不同造成的，所谓寻址便是确定如何寻找操作数的过程。
不管指令需要结合多少个操作数，指令执行过程中数据的流向是唯一的，那就是从SRC -&gt; DST。并且在数据传递的过程中必须保障SRC和DST长度大小明确且一致。
指令系统的寻址主要包括两类：
 数据的寻址方式：寻找指令所操作数据的方式 转移地址的寻址方式：寻找转移指令所需的程序地址  数据的八种寻址方式：
 立即数寻址 寄存器寻址 存储器寻址  直接寻址 寄存器间接寻址 寄存器相对寻址 基址变址寻址 基址变址寻址且相对寻址   隐含寻址  立即数寻址 MOV AX, 100H ; 十六进制立即数 MOV BX, 1010 ; 十进制立即数 MOV AX, 12Q ; 八进制立即数 MOV AX, 0101B ; 二进制立即数 立即数只能作为源操作数（SRC）使用，无法作为目的操作数。立即数所占据的内存大小由目的操作数决定。且立即数本身长度不得超出目的操作数长度。
MOV AL, 10H ; 10H占据一个Byte的空间 MOV AX, 10H ; 10H占据一个Word的空间  MOV AL, 1010H ; ❌ 1010H占据一个Word的空间无法放入一个Byte的寄存器中 MOV 1010H, AX ; ❌ 立即数无法作为DST 注：CS寄存器在立即数寻址过程中无法作为目的操作数使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%9F%BA%E4%BA%8E%E6%A0%88vm/" rel="bookmark">
			后缀表达式与基于栈VM
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-09-19T16:02:13&#43;08:00">2021-09-19</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		后缀表达式 算术运算表达式有三种形式，分别为“中缀表达式”，“后缀表达式”和“前缀表达式”。
中缀表达式是让数据结合在算符的两侧，例如a * (b + c) - d。这种表达式也是我们使用最多，最符合人类思考方式的算术运算表达形式。
前缀表达式与后缀表达式类似，后缀表达式是将算符置于数据之后，例如a b c + * d -。前缀表达式是将运算符置于数据之前，例如+ * a b c - d。
最常使用的中缀表达式可以通过一定的算法转换为后缀或者前缀表达式。
通过观察不难发现，后缀表达式在计算时是有序的，所谓有序就是我们只需遍历整个表达式就能得到表达式的结果，无需考虑运算符之间的优先级顺序（中缀表达式显然需要考虑算符之间的优先级顺序，而后缀表达式是已经按照运算符顺序进行排好序的表达式序列）。
后缀表达式的计算  算法准备    后缀表达式
  数据栈
   算法阐述    遍历后缀表达式字符串
  如果字符串是数字，转换为数字并压入数据栈
  如果是支持的算符，根据算符的数据结合性（一元算符结合一个数据，二元算符结合两个数据，不考虑算符的左结合和右结合）从栈中弹出指定数量的数据
  将弹出的数据按照算符计算规则进行计算，并重新压入栈
   Java代码实现  ArrayDeque&lt;Double&gt; operatorNumberStack = new ArrayDeque&lt;&gt;(); for (String token : tokenStream) { if (isSupportedOperator(token.charAt(0))) { double a, b = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%9F%BA%E4%BA%8E%E6%A0%88vm/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/leetcode18/" rel="bookmark">
			Leetcode18及关于算法的一些思索
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-09-10T00:00:00Z">2021-09-10</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给你一个由n个整数组成的数组nums，和一个目标值target。请你找出并返回满足下述全部条件且不重复的四元组[nums[a], nums[b], nums[c], nums[d]]:
  0 &lt;= a, b, c, d &lt;= n
  a, b, c, d互不相同
  nums[a] + nums[b] + nums[c] + nums[d] == target
  你可以按 任意顺序 返回答案。
题目链接：https://leetcode-cn.com/problems/4sum/
思路分析 本题与leetcode15题三数之和十分相似，对于三数之和问题，我也在之前的文章中进行了叙述https://mananbc1st.github.io/posts/leetcode15/，其主体算法思想为排序+贪心的策略（三指针求解）。
那么对于四数之和可以看作是三数之和问题的推广，理解了其求解的方式，你可以写出N数之和的算法。
如何从已知的三数之和问题为条件去求解四数之和乃至N数之和的问题呢？
主要思想还是讲问题分解为可以求解的子问题，也就是问题归约法
具体的实现逻辑为：递归 + 回溯。
Java AC代码 private final List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); private void doSearchOpt(int[] nums, int start, int target, List&lt;Integer&gt; container) { if (container.size() == 1) { // 只要将问题递归至三数之和问题，就达到了算法的递归基  // 因为三数之和问题有解  for (int i = start; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/leetcode18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/%E9%80%9A%E7%94%A8%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/" rel="bookmark">
			组合算法(Java实现)
			</a>
		</h2>
		<div class="list__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Manan</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-09-07T00:00:00Z">2021-09-07</time></div></div>
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合算法 排列组合是一个重要的数学概念，组合通常用来枚举从一个集合中选择特定个数元素的所有结果。
实现与思路阐述 实现方式：递归 + 回溯法。
时间复杂度: O(n ^ x)，其中x代表选择元素的个数。
import java.util.ArrayList; import java.util.List; public final class CombinationAlgorithm&lt;ElementType&gt; { private final List&lt;List&lt;ElementType&gt;&gt; res = new ArrayList&lt;&gt;(); private void doSelect(List&lt;ElementType&gt; collection, int start, int selectionNumber, List&lt;ElementType&gt; container) { if (selectionNumber == 0) { res.add(new ArrayList&lt;&gt;(container)); return; } for (int i = start, len = collection.size(); i &lt; len; ++i) { container.add(collection.get(i)); doSelect(collection, i + 1, selectionNumber - 1, container); // 回溯  container.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/%E9%80%9A%E7%94%A8%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/2</span>
	<a class="pagination__item pagination__item--next btn" href="/page/2/">»</a>
</div>

			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="SEARCH…" value="" name="q" aria-label="SEARCH…">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="/" />
	</form>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/posts/%E5%8D%9A%E5%BC%88%E6%A0%91%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/">博弈树的启发式搜索</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/javascript-zx%E7%94%A8js%E5%86%99shell%E8%84%9A%E6%9C%AC/">JavaScript ZX——用JS写Shell脚本</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/swing%E7%B1%BB%E5%BA%93%E6%B1%87%E6%80%BB/">Java Swing类库汇总</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/%E5%B0%86java%E7%BC%96%E8%AF%91%E4%B8%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81/">将Java编译为本地代码</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">哈夫曼树与哈夫曼编码</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/java/" title="Java">Java (4)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/javascript/" title="JavaScript">JavaScript (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/leetcode/" title="leetcode">leetcode (3)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/" title="微机原理">微机原理 (2)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/" title="智能算法">智能算法 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" title="杂七杂八">杂七杂八 (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%E7%AE%97%E6%B3%95/" title="算法">算法 (5)</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 版权声明：署名-非商业使用-相同方式共享 3.0 国际(BY-NC-SA 3.0).
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script></body>
</html>